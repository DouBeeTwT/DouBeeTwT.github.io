---
title: 一种基于隐马尔科夫模型的股价涨跌区间预测方法
description: 股票作为现代经济中一种重要的融资手段正在被广泛的使用在商业以及个人投资领域。对于股票的甄别选自也有种类繁多的体系与理论。以前重要的两个派别是技术指标派和K线派，但随着近年来计算机的普及与性能的提升，通过编制特定的程序控制买卖时间点的量化交易派逐渐兴起。本文将以隐马尔科夫模型为判别模型，考察其在应用与股票投资上的适合性。
categories:
 - 论文
tags: HMM python R 
---

## 第一章 量化交易与隐马尔科夫模型

### 量化交易

股票作为现代经济中一种重要的融资手段正在被广泛的使用在商业以及个人投资领域。对于股票的甄别选自也有种类繁多的体系与理论。以前重要的两个派别是技术指标派和K线派，但随着近年来计算机的普及与性能的提升，通过编制特定的程序控制买卖时间点的量化投资派逐渐兴起。

#### 量化交易的概念

量化交易是指以先进的数学模型替代人为的主观判断，利用计算机技术从庞大的历史数据中海选能带来超额收益的多种“大概率”事件以制定策略，极大地减少了投资者情绪波动的影响，避免在市场极度狂热或悲观的情况下作出非理性的投资决策。

#### 量化交易的特点

定量投资和传统的定性投资本质上来说是相同的，二者都是基于市场非有效或弱有效的理论基础。两者的区别在于定量投资管理是“定性思想的量化应用”，更加强调数据。量化交易具有以下几个方面的特点：

1. 纪律性。根据模型的运行结果进行决策，而不是凭感觉。纪律性既可以克制人性中贪婪、恐惧和侥幸心理等弱点，也可以克服认知偏差，且可跟踪。
2. 系统性。具体表现为“三多”。一是多层次，包括在大类资产配置、行业选择、精选具体资产三个层次上都有模型；二是多角度，定量投资的核心思想包括宏观周期、市场结构、估值、成长、盈利质量、分析师盈利预测、市场情绪等多个角度；三是多数据，即对海量数据的处理。
3. 套利思想。定量投资通过全面、系统性的扫描捕捉错误定价、错误估值带来的机会，从而发现估值洼地，并通过买入低估资产、卖出高估资产而获利。
4. 概率取胜。一是定量投资不断从历史数据中挖掘有望重复的规律并加以利用；二是依靠组合资产取胜，而不是单个资产取胜。

#### 量化交易的应用——算法交易

算法交易又称自动交易、黑盒交易或机器交易，是指通过设计算法，利用计算机程序发出交易指令的方法。在交易中，程序可以决定的范围包括交易时间的选择、交易的价格，甚至包括最后需要成交的资产数量。算法交易的主要类型有: 

1. 被动型算法交易，也称结构型算法交易。该交易算法除利用历史数据估计交易模型的关键参数外，不会根据市场的状况主动选择交易时机和交易的数量，而是按照一个既定的交易方针进行交易。该策略的的核心是减少滑价（目标价与实际成交均价的差）。被动型算法交易最成熟，使用也最为广泛，如在国际市场上使用最多的成交加权平均价格（VWAP）、时间加权平均价格（TWAP）等都属于被动型算法交易。
2. 主动型算法交易，也称机会型算法交易。这类交易算法根据市场的状况作出实时的决策，判断是否交易、交易的数量、交易的价格等。主动型交易算法除了努力减少滑价以外，把关注的重点逐渐转向了价格趋势预测上。
3. 综合型算法交易，该交易是前两者的结合。这类算法常见的方式是先把交易指令拆开，分布到若干个时间段内，每个时间段内具体如何交易由主动型交易算法进行判断。两者结合可达到单纯一种算法无法达到的效果。

#### 小结
对于股票来说，一只好的股票由于不当的买入卖出时机亦有可能造成投资的失败或至少是盈利的减少。所以本文中并未按照量化交易的最基本出发点选股着手，而是着眼于对一只已选定的股票，什么样的买入与卖出时机能保证自己的盈利。即在本文中我们利用隐马尔科夫模型去模拟股价的一种潜在的涨跌区间交替关系，依此为根据决定股票的买入与卖出，控制了量化交易的时间选择，避免了人为选择的“追涨杀跌”等不理性行为，提高了风险规避能力，增加了机会找寻概率。同时，这样的控制存在着更加普适的意义，即无论什么样的股票都能增加盈利或者减少损失。

### 隐马尔科夫模型
过程或（系统）在时刻t0所处的状态为已知的条件下，过程在时刻t>t0所处状态的条件分布与过程在时刻t0之前所处的状态无关的特性称为马尔可夫性，而具有马尔可夫性的随机过程称为马尔可夫过程。

$$P(X(t_{n}) \leq x_{n}\|X(t_{i})=x_{i})=P(X(t_{n}) \leq x_{n}\|X(t_{n-1})=x_{n-1})$$

在简单的马尔可夫模型（如马尔可夫链），所述状态是直接可见的观察者，因此状态转移概率是唯一的参数。在隐马尔可夫模型中，状态是不直接可见的，但输出依赖于该状态下，是可见的。每个状态通过可能的输出记号有了可能的概率分布。因此，通过一个HMM产生标记序列提供了有关状态的一些序列的信息。注意，“隐藏”指的是，该模型经其传递的状态序列，而不是模型的参数；即使这些参数是精确已知的，我们仍把该模型称为一个“隐藏”的马尔可夫模型。隐马尔可夫模型以它在时间上的模式识别所知，如语音，手写，手势识别，词类的标记，乐谱，局部放电和生物信息学应用。基于隐马尔科夫模型存在三个问题与对应的算法：
#### 评估问题： 前向算法
#### 解码问题： Viterbi算法
#### 学习问题： Baum-Welch算法

## 第二章 实验结果与讨论

本文通过隐马尔可夫模型，对输入的股票显式序列进行建模从而得到推测的隐式序列。对于股票的显式序列有两种来源：一是通过股价的布朗运动规律，自动随机生成人造股价波动。第二是从[雅虎财经](https://hk.finance.yahoo.com/)上下载上证50的股票从上市到2018年4月25日的所有股价数据。以此为两种原始数据来源构建统一格式的股价显式序列，即如果当日收盘价大于开盘价则记录为“R”(red),反之记录为“G”(green)。

|若收盘价-开盘价|+0.13|+0.21|-0.43|+0.54|-0.22|-0.23|-0.11|+0.02|-0.05|
|记录的显式序列 |R    |R    |G    |R    |G    |G    |G    |R    |G    |

### 模拟股价测试

#### 基于几何布朗运动的人工股价随机函数
对于人工股价随机函数，这里用到几何布朗运动ln(S(y+t)/S(y))~N(mu,sigma)，此处我们取时间t为一天，表示连续两天股价之比的对数值满足高斯分布。于是所得代码如下：

```python
import matplotlib.pyplot as plt
import numpy as np

def Price(f=0.02,u=0,t=200):
    v = f*np.random.randn(t)+u
    P=[1]
    for i in range (t-1):
        P.append(P[i]*np.exp(v[i]))
    plt.plot(P)
    plt.show()
    return P,v

\#价格水平通道曲线
Price()

\#价格上升通道曲线
Price(u=0.01)

\#价格下降通道曲线
Price(u=-0.01)

```

![图片1](/source/HMM/Price.png)

函数Price(f,u,t)中的f表示波动程度，默认为2%;u表示偏移量即表征了服从的高斯分布的均值大小,默认为0;t表示需要生成的股价天数，默认200天。依照编程函数生成的股价曲线如图1，从图中我们也可以发现其走势确实如我们所见的真实股票一样存在着波动，且随着u值的改变，改变了股价的走势。(出于美观性考虑此图由Python运行后的数据使用R中的ggplot做图)

#### 隐马尔可夫模型简单测试

```python

```

![图片2](/source/HMM/test1.png)

通过隐马尔可夫模型对我们上一步所说的基于几何布朗运动的人工股价随机函数生成的显式序列进行拟合，Viterbi算法推测所得的最大概率隐式序列可视化表示如上图。从图中我们可以发现,通过隐马尔可夫模型处理后的涨跌区间有着较好的拟合。在70-170天与650-800天这两段明显的下跌区间中甚至依旧可以找到一小段的回升，220-300天的震荡区间中也可以发现明显的上涨下跌交替出现的情况。

#### 小结
通过对人工生成的股价测试结果来看，隐马尔可夫模型存在这一定的可行性。对于一段不明确上涨或下跌趋势的波动区间能有效的识别出其隐藏的上涨下跌区间。在明显的下跌区间中能依旧能有效的识别出一小段上涨区间，且一段上下波动的区间中也会灵活的识别转换隐式状态。这以简单的测试说明了隐马尔可夫模型对于股价变化的识别有效，这为我们下一步继续对上证50真实数据进行进一步测试提供了保障。

### 上证50真实数据回测
首先，我们需要对所选数据做一个基本解释。我们所用的数据取自雅虎财经，由于沪市上市的所有股票较多，所以我们选取了比较代表这一股市的上证50成分股。由于上证50作为一个股市的衡量指数，其成分股存在变动，我们选择的是2017年01月06日发布的样本，其中信威集团(600485)未在雅虎财经中找到数据故换取2015年08月31日中发布的样本国电南瑞 (600406)。综上我们这次的上证50真实数据测试的股票集合如下表:

|浦发银行 (600000)|民生银行 (600016)|中国石化 (600028)|南方航空 (600029)|中信证券 (600030)|
|招商银行 (600036)|保利地产 (600048)|中国联通 (600050)|同方股份 (600100)|上汽集团 (600104)|
|国金证券 (600109)|北方稀土 (600111)|国电南瑞 (600406)|康美药业 (600518)|贵州茅台 (600519)|
|山东黄金 (600547)|东方明珠 (600637)|海通证券 (600837)|伊利股份 (600887)|中航动力 (600893)|
|东方证券 (600958)|招商证券 (600999)|大秦铁路 (601006)|中国神华 (601088)|兴业银行 (601166)|
|北京银行 (601169)|中国铁建 (601186)|东兴证券 (601198)|国泰君安 (601211)|农业银行 (601288)|
|中国平安 (601318)|交通银行 (601328)|新华保险 (601336)|兴业证券 (601377)|中国中铁 (601390)|
|工商银行 (601398)|中国太保 (601601)|中国人寿 (601628)|中国建筑 (601668)|华泰证券 (601688)|
|中国中车 (601766)|光大证券 (601788)|中国交建 (601800)|光大银行 (601818)|中国石油 (601857)|
|方正证券 (601901)|中国核电 (601985)|中国银行 (601988)|中国重工 (601989)|中信银行 (601998)|	

对于这些股票，我们下载其从上市到2018年4月25日的每天开盘价与收盘价，如之前已叙述，通过转化价格差的数据变成显式序列，用隐马尔可夫模型得到可能的隐式序列，经过测试所得数据通过R做图汇总如下

![图片3](/source/HMM/test2.png)
![图片4](/source/HMM/RESULT.png)

#### 单一股票定时测试

我们选取浦发银行（600000）作为分析对象，如图中所示，我们采取的策咯是在上升区间转下降区间后卖出股票，在下降区间转上升区间后买入。由于信息滞后性，我们只有在出现转换后的第一天才知道转换的出现，因此我们将只有在转换出现的第二天买入或者卖出。即使如此，首先我们的模型有效的识别了上涨与下跌的区间，虽然在上涨区间中有下跌的错误识别但是对于整体一段上涨区间中结果依旧是上涨的；其次延后一天的投资依旧有可观的效果。对于本次测试我们选取的是最近300天的数据，**最终虽然这一年的股票价格下跌了10%左右，但是运用隐马尔可夫建立的投资规则下投资可获得近40%的收益。**
```python
import csv
Data = []
with open('600000.csv','rb') as ff:
    reader = csv.reader(ff)
    for row in reader:
        Data.append(row)
O = ""
Price = []
Rate0 = []
for i in range(len(Data)-2):
    if(Data[i+2][4]!="null" and Data[i+1][4]!="null"):
        Price.append(Data[i+1][4])
        Rate0.append(float(Data[i+2][4])/float(Data[i+1][4]))
        if (float(Data[i+2][4])-float(Data[i+1][4])>=0):
            O = O + "R"
        else:
            O = O + "G"
            
import matplotlib.pyplot as plt
days = 300
Hdline = Viterbi(O,[[0.6, 0.4], [0.4, 0.6]],[[0.6, 0.4], [0.4, 0.6]])
fig, ax = plt.subplots(figsize=(16, 4))
for i in range (len(O)-days-1,len(O)-1):
    if Hdline[i] == "U":
        ax.plot([i],[Price[i]],'ro')
    elif Hdline[i] == "D":
        ax.plot([i],[Price[i]],'go')
plt.show()
\#图像化显示计算出的涨跌区间

fig, ax = plt.subplots(figsize=(16, 4))
Price_my = [1]
flag = False
for i in range (len(O)-days,len(O)):
    if flag == False:
        Price_my.append(Price_my[len(Price_my)-1]*1.0)
    else:
        Price_my.append(Price_my[len(Price_my)-1]*Rate0[i])
    if Hdline[i-1] == "U" and  Hdline[i] == "D":
        flag = False
    elif Hdline[i-1] == "D" and Hdline[i] == "U":
        flag = True
ax.plot(Price_my,'b')
plt.show()
\#依照此涨跌去购买的收益曲线
```
#### 单一股票时间变动测试

单个300天的小测试似乎不足以说明程序的有效性是否具有普遍的意义，于是我们继续拓宽被测试的时间取样。以300天为一个取样窗口，以最近300天为第一个取样窗口，每次向前滑动50天，共取样50组300天的数据进行如上一节所说的测试，计算出每组数据的投资收益与事实上的股票价格变动，如图A,B所示结果。图A中，横坐标为300天股价变动比例，纵坐标为300天投资收益比例，图中的直线表示在这300天结束时，投资收益等于实际价格变动时的情况，即无需任何操作，在开始时买入后持有300天卖出。我们可以发现所有的点均位于直线上方，这意味着当我们对一只股票持有达到300天时，使用隐马尔可夫模型决定买卖时机的投资策略总是优于直接持有300天。这一点很好的说明了本文所使用的方法有效地优化了我们的投资收益。其次B图中蓝色柱状表示我们的投资收益比例，而红色柱状表示的是实际300天后的价格变动，按照投资收益比例降序排列。图中的虚线表示的是投资收益比例为1的情况，即投资保本线。从图中我们欣喜地发现，虽然实际的股价变动在300天这一大的区间中不免有上下波动而出现亏损的情况，但是我们的投资收益比例无一例外的高于1，即盈利。**这意味着在充分长的时间段内使用本文的方法，对于一直特定的股票来说，无论是什么时期，它不但能保证你的收益会优于直接持有改股票，而且几乎一定能保证正收益。**

```python
import csv

def F(x):
    if x == 'U':
        return 0
    else:
        return 1
    
def f(x):
    if x == 'R':
        return 0
    else:
        return 1
def right(O,Hdline,days,x):
    t_num=0
    f_num=0
    for i in range(len(O)-days-x*50,len(O)-x*50):
        if f(O[i]) == F(Hdline[i]):
            t_num=t_num+1
        else:
            f_num=f_num+1
    return float(t_num)/float(f_num+t_num)

def main(filename,x):
    #print("%-15s %-15s %-15s %-15s"%("偏移天数","投资收益","实际涨幅","准确率"))
    Data = []
    with open(filename,'rb') as ff:
        reader = csv.reader(ff)
        for row in reader:
            Data.append(row)
    O = ""
    Price = []
    Rate0 = []
    for i in range(len(Data)-2):
        if(Data[i+2][4]!="null" and Data[i+1][4]!="null"):
            Price.append(Data[i+1][4])
            Rate0.append(float(Data[i+2][4])/float(Data[i+1][4]))
            if (float(Data[i+2][4])-float(Data[i+1][4])>=0):
                O = O + "R"
            else:
                O = O + "G"
    Hdline = Viterbi(O,[[0.6, 0.4], [0.4, 0.6]],[[0.6, 0.4], [0.4, 0.6]])

    Price_my = 1
    flag = False
    days = 300
    for i in range (len(Price)-days-x*50,len(Price)-x*50):
        if flag == False:
            Price_my = Price_my*1.0
        else:
            Price_my = Price_my*Rate0[i]
        if Hdline[i-1] == "U" and  Hdline[i] == "D":
            flag = False
        elif Hdline[i-1] == "D" and Hdline[i] == "U":
            flag = True
    print("%-11.6s %-11.2f %-11.2f %-11.2f"%(x*50,round(Price_my,2),
                                             float(Price[len(Price)-1-x*50])/float(Price[len(Price)-1-days-x*50]),
                                             right(O,Hdline,days,x)))

print("%-15s %-15s %-15s %-15s"%("偏移天数","投资收益","实际涨幅","准确率"))
for i in range(100):
    main('600000.csv',i)
```

|偏移天数|投资收益|实际涨幅|准确率|      
|0      |1.39   |0.91   |0.77 |       
|50     |1.43   |1.03   |0.77 |      
|100    |1.48   |1.05   |0.78 |      
|150    |1.54   |1.03   |0.81 |       
|200    |1.53   |1.02   |0.81 |      
|···    |···    |···    |···  |
|4750   |1.52   |1.02   |0.80 |       
|4800   |1.51   |1.03   |0.81 |       
|4850   |1.42   |1.01   |0.79 |       
|4900   |1.56   |1.11   |0.80 |       
|4950   |2.01   |1.17   |0.81 |

#### 上证50样本300天测试

经过之前的分析测试，我们完成了本文方法对单一特定股票的适应性证明。现在我们拓宽股票池的选择，以上证50中的50只样本股作为测试目标，考察此方法对其他股票是否有一样的适配性，测试结果如图C、D。分析方法与上一节类似，从图C中我们不难看出即使是推演到50只不同的股票，图中收益比例与实际价格做出的点都在等价值线的上方，意味着对于不同的股票当我们对一只股票持有达到300天时，使用隐马尔可夫模型决定买卖时机的投资策略总是优于直接持有300天。而图D中所有的蓝色柱状都高于保本线，可见即使多余不同的股票，本文中的投资方法依旧有良好的保本性。**这意味着在充分长的时间段内使用本文的方法，对于不同的股票都能保证你的收益会优于直接持有改股票，而且几乎一定能保证正收益。**

```python
def right(O,Hdline):
    t_num=0
    f_num=0
    for i in range(len(O)-days,len(O)):
        if f(O[i]) == F(Hdline[i]):
            t_num=t_num+1
        else:
            f_num=f_num+1
    return float(t_num)/float(f_num+t_num)

def result(f_list):
    print("%-15s %-15s %-15s %-15s"%("股票代码","投资收益","实际涨幅","准确率"))
    for i in range (len(f_list)):
        main(f_list[i])

def main(filename):
    Data = []
    with open(filename,'rb') as ff:
        reader = csv.reader(ff)
        for row in reader:
            Data.append(row)
    O = ""
    Price = []
    Rate0 = []
    for i in range(len(Data)-2):
        if(Data[i+2][4]!="null" and Data[i+1][4]!="null"):
            Price.append(Data[i+1][4])
            Rate0.append(float(Data[i+2][4])/float(Data[i+1][4]))
            if (float(Data[i+2][4])-float(Data[i+1][4])>=0):
                O = O + "R"
            else:
                O = O + "G"
            
    days = 300
    Hdline = Viterbi(O,[[0.6, 0.4], [0.4, 0.6]],[[0.6, 0.4], [0.4, 0.6]])

    Price_my = 1
    flag = False
    for i in range (len(Price)-days,len(Price)):
        if flag == False:
            Price_my = Price_my*1.0
        else:
            Price_my = Price_my*Rate0[i]
        if Hdline[i-1] == "U" and  Hdline[i] == "D":
            flag = False
        elif Hdline[i-1] == "D" and Hdline[i] == "U":
            flag = True
    print("%-11.6s %-11.2f %-11.2f %-11.2f"%(filename,round(Price_my,2),
                                             float(Price[len(Price)-1])/float(Price[len(Price)-1-days]),right(O,Hdline)))
result(['600000.csv','600016.csv','600028.csv','600029.csv','600030.csv',
       '600036.csv','600048.csv','600050.csv','600100.csv','600104.csv',
       '600109.csv','600111.csv','600406.csv','600518.csv','600519.csv',
       '600547.csv','600637.csv','600837.csv','600887.csv','600893.csv',
       '600958.csv','600999.csv','601006.csv','601088.csv','601166.csv',
       '601169.csv','601186.csv','601198.csv','601211.csv','601288.csv',
       '601318.csv','601328.csv','601336.csv','601377.csv','601390.csv',
       '601398.csv','601601.csv','601628.csv','601668.csv','601688.csv',
       '601766.csv','601788.csv','601800.csv','601818.csv','601857.csv',
       '601901.csv','601985.csv','601988.csv','601989.csv','601998.csv'])
```

|股票代码|投资收益|实际涨幅|准确率|股票代码|投资收益|实际涨幅|准确率|      
|600000  |1.39    |0.91    |0.77  |601169  |1.27    |0.81    |0.80  |     
|600016  |1.54    |0.85    |0.79  |601186  |1.70    |0.80    |0.75  |     
|600028  |1.84    |1.15    |0.80  |601198  |1.35    |0.73    |0.73  |     
|600029  |2.41    |1.34    |0.76  |601211  |1.43    |0.93    |0.78  |     
|600030  |1.74    |1.17    |0.76  |601288  |1.97    |1.20    |0.83  |     
|600036  |2.56    |1.52    |0.81  |601318  |3.08    |1.82    |0.77  |     
|600048  |2.76    |1.53    |0.81  |601328  |1.52    |1.03    |0.79  |     
|600050  |1.71    |0.87    |0.84  |601336  |2.29    |0.95    |0.78  |     
|600100  |1.30    |0.82    |0.85  |601377  |1.53    |0.83    |0.77  |     
|600104  |2.08    |1.26    |0.80  |601390  |1.26    |0.84    |0.73  |     
|600109  |1.66    |0.64    |0.79  |601398  |1.93    |1.32    |0.80  |     
|600111  |2.31    |1.03    |0.75  |601601  |3.00    |1.14    |0.83  |     
|600406  |1.19    |1.03    |0.82  |601628  |1.83    |0.97    |0.76  |     
|600518  |1.71    |1.05    |0.79  |601668  |1.75    |0.94    |0.76  |     
|600519  |2.32    |2.00    |0.79  |601688  |2.11    |1.00    |0.80  |     
|600547  |1.56    |0.77    |0.81  |601766  |1.72    |0.96    |0.75  |     
|600637  |1.40    |0.74    |0.77  |601788  |1.43    |0.78    |0.80  |     
|600837  |1.38    |0.71    |0.75  |601800  |1.66    |0.84    |0.78  |     
|600887  |2.53    |1.58    |0.81  |601818  |1.59    |0.99    |0.82  |     
|600893  |2.21    |0.80    |0.79  |601857  |1.38    |0.89    |0.73  |     
|600958  |1.42    |0.75    |0.75  |601901  |1.44    |0.76    |0.79  |     
|600999  |1.62    |1.00    |0.77  |601985  |1.27    |0.93    |0.79  |     
|601006  |1.88    |1.16    |0.81  |601988  |1.73    |1.07    |0.82  |     
|601088  |1.99    |1.23    |0.82  |601989  |1.33    |0.69    |0.86  |     
|601166  |1.39    |0.96    |0.79  |601998  |1.73    |0.93    |0.79  |

#### 小结

### 局限性分析

#### 实际问题

#### 参数估计问题

#### 小结

## 第三章 结论

## 引用